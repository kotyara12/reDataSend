# reDataSend
Универсальная библиотека ESP32 & ESP-IDF для отправки данных на [**народный мониторинг**](https://narodmon.ru/?invite=kotyara12), [**open-monitoring.online**](http://open-monitoring.online/) и [**thingspeak**](https://thingspeak.com/) посредством HTTP(S) протокола. 

Отправка данных реализована в отдельной задаче FreeRTOS с автоматическим контролем минимально допустимых интервалов записи в канал / контроллер / устройство. При этом ставить новые данные в очередь отправки вы можете сколь угодно часто без опасений получить бан или блокировку со стороны сервера.

## Использование библиотеки

**Шаг 1. Запустите задачу**

Вначале вам необходимо создать и запустить задачу _data_send_ (один раз при запуске контроллера). Сделать это можно с помощью функции:
```c
bool dsTaskCreate(bool createSuspended);
```
Если **createSuspended = true**, то созданная задача будет приостанвлена до момента получения уведомления через системный цикл событий, что доступ в сеть интернет имеется, и можно начинать отправку данных. Иначе задача сразу же будет запущена в работу.

С помощью дополнительных функций вы можете приостановить или возвобновить выполнение задачи на время отсутствия подключения к сети:
```c
bool dsTaskSuspend();
bool dsTaskResume();
```

**Шаг 2. Инициализация контроллеров**

Затем создайте "учетные записи" для каждого канала / контроллера / устройства, в которые будет осуществляться отправка данных. В контексте данной библиотеки это называется _инициализация контроллера_. Это также делается только один раз, но для каждого канала / контроллера / устройства. При этом во внутреннем списке задачи сохраняются данные об идентификаторе контроллера, токене или ключе записи на сайт и минимальном интервале отправки новых данных. 

Используйте следюущую функцию:
```c
bool dsChannelInit(ext_data_service_t kind, uint32_t uid, const char *key, uint32_t min_interval, uint32_t err_interval);
```
_где:_
- **kind** - тип контроллера
```c
typedef enum {
  EDS_OPENMON = 0,
  EDS_NARODMON,
  EDS_THINGSPEAK
} ext_data_service_t;
```
- **uid** - идентификатор контроллера/канала/устройства, обычно он выдается самим сервисом при создании контроллера (но для народного мониторинга вы можете взять любой случайный)

- **key** - ключ доступа к сервису (токен или MAC-адрес)

- **min_interval** - минимальный интервал отправки данных на сервис в секундах в нормальном режиме

- **err_interval** - минимальный интервал повторной отправки данных на сервис в секундах в случае ошибки

Никакого физического обмена данными с сервисом при инициализации не происходит. При всех последующих обращениях к контроллеру вам потребуется указывать только его **uid**.

**Шаг 3. Отправка данных в очередь задачи**

Для отправки данных в канал/контроллер заранее подготовьте данные в формате используемого сервиса:

- для [народного мониторинга](https://narodmon.ru/?invite=kotyara12) имена параметров могут быть произвольными, например **Tout=10.00&Tin=25.00&...**
- для [open-monitoring.online](http://open-monitoring.online/) имена полей обозначены буквой p и номером по порядку: **p1=10,00&p2=25.00&...**
- для [thingspeak](https://thingspeak.com/) используется похожий принцип, но имена полей обозначены словом field: **field1=10,00&field2=25.00&...**

Никакие дополнительные поля к этим данным добавлять не нужно – библиотека сама добавит идентификатор и токен доступа при отправке.

Затем отправьте подготовленные данные в очередь с помощью функции
```c
bool dsSend(ext_data_service_t kind, uint32_t uid, char *data, bool free_data)
```

где:

- **data** – указатель на строку данных в куче
- **free_data** – если указать здесь true, то после добавления задания в очередь строка **data** будет удалена из кучи, в противном случае вы должны сделать это самостоятельно.

После вызова **dsSend()** данные попадают в исходящую очередь. Если добавление задания в очередь прошло успешно, функция вернет **true**.

Далее задача проверяет, как давно происходила отправка в этот самый контроллер. Если время превышает минимальный интервал отправки, то делается попытка немедленно отправить данные. Если минимальный интервал ещё не истёк, то данные остаются в очереди. Но если во время ожидания поступят новые данные в этот же самый контроллер, то они будут заменены новыми данными. Этот механизм позволяет отправлять данные в очередь не заботясь об минимальных интервалах отправки.

## Примечания
Данные замечания относятся к моим библиотекам, размещенным на ресурсе https://github.com/kotyara12?tab=repositories.

- библиотеки, название которых начинается с префикса **re**, предназначены только для ESP32 и ESP-IDF (FreeRTOS)
- библиотеки, название которых начинается с префикса **ra**, предназначены только для ARDUINO
- библиотеки, название которых начинается с префикса **r**, могут быть использованы и для ARDUINO, и для ESP-IDF

Так как я в настроящее время разрабатываю программы в основном для ESP-IDF, основная часть моих библиотек предназначена только для этого фреймворка. Но Вы можете портировать их для другой системы, взяв за основу.


## Лицензия
Эта библиотека является бесплатным программным обеспечением; вы можете распространять и / или изменять его в соответствии с условиями Стандартной общественной лицензии ограниченного применения GNU, опубликованной Free Software Foundation; либо версии 2.1 Лицензии, либо (по вашему выбору) любой более поздней версии.

Эта библиотека распространяется в надежде, что она будет полезна, но _БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ_; _даже без подразумеваемых гарантий ТОВАРНОЙ ПРИГОДНОСТИ или ПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ ЦЕЛИ_. Подробнее см. Стандартную общественную лицензию ограниченного применения GNU.

